{"version":3,"sources":["../src/index.ts"],"names":["generateRandomString","level","index","str","Math","random","toString","substr","generateCascade","name","value","CascadeHelper","subKey","valueKey","cascades","labels","endLevel","results","traverse","strs","path","cascade","cStrs","label","cLevel","cPath","push","count","startLevel","geterateFunc","newCascades","setInit","xIndex","choice","cb","cascadesForEach","levels","acc","_curr","join","values","parent","prevLevel","querySubCascades","subCascades","targetValue","current","currentIndex"],"mappings":";;;;;;;AAAA;;;;;;;;;;AAoBO,IAAMA,oBAAoB,GAAG,SAAvBA,oBAAuB,GAAkD;AAAA,MAAjDC,KAAiD,uEAAjC,CAAiC;AAAA,MAA9BC,KAA8B,uEAAd,CAAc;AACpF,MAAMC,GAAG,GAAGC,IAAI,CAACC,MAAL,GACTC,QADS,CACA,EADA,EAETC,MAFS,CAEF,CAFE,EAEC,CAFD,CAAZ;AAIA,SAAOJ,GAAG,GAAG,GAAN,GAAYF,KAAZ,GAAoB,GAApB,GAA0BC,KAAjC;AACD,CANM;;;;AAQP,IAAMM,eAAe,GAAG,SAAlBA,eAAkB,CAACP,KAAD,EAAgBC,KAAhB;AAAA,SAA4C;AAClEO,IAAAA,IAAI,YAAKR,KAAL,cAAcC,KAAd,CAD8D;AAElEQ,IAAAA,KAAK,EAAEV,oBAAoB,CAACC,KAAD,EAAQC,KAAR;AAFuC,GAA5C;AAAA,CAAxB;;IAKMS,a;;;AAGJ,2BAA4E;AAAA,QAAzDC,MAAyD,uEAAxC,UAAwC;AAAA,QAA5BC,QAA4B,uEAAT,OAAS;;AAAA;;AAAA;;AAAA;;AAC1E,SAAKD,MAAL,GAAcA,MAAd;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACD;;;;4BAEcC,Q,EAAgF;AAAA,UAA3DC,MAA2D,uEAAxC,EAAwC;AAAA,UAApCC,QAAoC;AAC7F,UAAMC,OAAwB,GAAG,EAAjC;AAD6F,UAErFL,MAFqF,GAE1E,IAF0E,CAErFA,MAFqF;;AAI7F,UAAMM,QAAQ,GAAG,SAAXA,QAAW,CAACJ,QAAD,EAA+E;AAAA,YAAzDK,IAAyD,uEAA5C,EAA4C;AAAA,YAAxCC,IAAwC;AAAA,YAAzBnB,KAAyB;AAC9F,6BAAQa,QAAR,EAAkB,UAACO,OAAD,EAAUnB,KAAV,EAAoB;AACpC,cAAIoB,KAAW,GAAG,EAAlB;AACA,+BAAQP,MAAR,EAAgB,UAACQ,KAAD,EAAW;AACzBD,YAAAA,KAAK,CAACC,KAAD,CAAL,GAAe,CAAC,yBAAYJ,IAAI,CAACI,KAAD,CAAhB,CAAD,GAA4BJ,IAAI,CAACI,KAAD,CAAJ,GAAc,GAAd,GAAoBF,OAAO,CAACE,KAAD,CAAvD,GAAiEF,OAAO,CAACE,KAAD,CAAvF;AACD,WAFD;AAIA,cAAIC,MAAM,GAAG,CAAC,yBAAYvB,KAAZ,CAAD,GAAsBA,KAAtB,GAA8B,CAA3C;AACA,cAAMwB,KAAK,GAAG,CAAC,yBAAYL,IAAZ,CAAD,aAAwBA,IAAxB,cAAgCR,MAAhC,cAA0CV,KAA1C,oBAAyDA,KAAzD,MAAd;;AAEA,cAAI,CAAC,qBAAQmB,OAAO,CAACT,MAAD,CAAf,CAAD,KAA8B,yBAAYI,QAAZ,KAA0B,CAAC,yBAAYA,QAAZ,CAAD,IAA0BQ,MAAM,GAAGR,QAA3F,CAAJ,EAA2G;AACzGQ,YAAAA,MAAM;AACN,mBAAON,QAAQ,CAACG,OAAO,CAACT,MAAD,CAAR,EAAkBU,KAAlB,EAAyBG,KAAzB,EAAgCD,MAAhC,CAAf;AACD;;AAEDP,UAAAA,OAAO,CAACS,IAAR,CAAa;AAAEP,YAAAA,IAAI,EAAEG,KAAR;AAAeD,YAAAA,OAAO,EAAE,uBAAUA,OAAV,CAAxB;AAA4CD,YAAAA,IAAI,EAAEK;AAAlD,WAAb;AACD,SAfD;AAgBD,OAjBD;;AAmBAP,MAAAA,QAAQ,CAACJ,QAAD,CAAR;AACA,aAAOG,OAAP;AACD;AAED;;;;;;mCASa;AAAA,UALXH,QAKW,uEALW,EAKX;AAAA,UAJXa,KAIW,uEAJK,CAIL;AAAA,UAHXC,UAGW,uEAHU,CAGV;AAAA,UAFXZ,QAEW,uEAFQ,CAER;AAAA,UADXa,YACW,uEAD+CrB,eAC/C;AAAA,UACHI,MADG,GACQ,IADR,CACHA,MADG;;AAEX,UAAIkB,WAAW,uBAAMlB,MAAN,EAAe,uBAAUE,QAAV,CAAf,CAAf;;AAEA,UAAIc,UAAU,GAAGZ,QAAjB,EAA2B;AACzB,eAAOc,WAAW,CAAClB,MAAD,CAAlB;AACD;;AAED,UAAMmB,OAAO,GAAG,SAAVA,OAAU,CAAC9B,KAAD,EAAgBoB,OAAhB,EAA2C;AACzD,YAAI,yBAAYA,OAAO,CAACT,MAAD,CAAnB,CAAJ,EAAkC;AAChCS,UAAAA,OAAO,CAACT,MAAD,CAAP,GAAkB,EAAlB;AACD;;AAED,YAAI,qBAAQS,OAAO,CAACT,MAAD,CAAf,CAAJ,EAA8B;AAC5B,6BAAMe,KAAN,EAAa,UAACK,MAAD,EAAY;AACvB,gBAAI,yBAAYX,OAAO,CAACT,MAAD,CAAP,CAAgBoB,MAAhB,CAAZ,CAAJ,EAA0C;AACxCX,cAAAA,OAAO,CAACT,MAAD,CAAP,CAAgBoB,MAAhB,IAA0BH,YAAY,CAAC5B,KAAD,EAAQ+B,MAAR,CAAtC;AACD;AACF,WAJD;AAKD;;AAED,6BAAQX,OAAO,CAACT,MAAD,CAAf,EAAyB,UAACqB,MAAD,EAAY;AACnC,cAAIhC,KAAK,GAAGe,QAAZ,EAAsB;AACpBe,YAAAA,OAAO,CAAC9B,KAAK,GAAG,CAAT,EAAYgC,MAAZ,CAAP;AACD;AACF,SAJD;AAKD,OAlBD;;AAoBAF,MAAAA,OAAO,CAACH,UAAD,EAAaE,WAAb,CAAP;AACA,aAAOA,WAAW,CAAClB,MAAD,CAAlB;AACD;AAED;;;;;;oCAIEE,Q,EACAoB,E,EAGM;AAAA;;AAAA,UAFNN,UAEM,uEAFe,CAEf;AAAA,UADNZ,QACM;AAAA,UACEJ,MADF,GACa,IADb,CACEA,MADF;AAGN,2BAAQE,QAAR,EAAkB,UAACO,OAAD,EAAUnB,KAAV,EAAoB;AACpCgC,QAAAA,EAAE,CAACb,OAAD,EAAUO,UAAV,EAAsB1B,KAAtB,CAAF;;AACA,YAAI,CAAC,qBAAQmB,OAAO,CAACT,MAAD,CAAf,CAAL,EAA+B;AAC7B,cAAII,QAAQ,IAAIY,UAAU,IAAIZ,QAA9B,EAAwC;AACtC;AACD;;AAED,UAAA,KAAI,CAACmB,eAAL,CAAqBd,OAAO,CAACT,MAAD,CAA5B,EAAsCsB,EAAtC,EAA0CN,UAAU,GAAG,CAAvD,EAA0DZ,QAA1D;AACD;AACF,OATD;AAUD;AAED;;;;;;;+BAIkBF,Q,EAAqBsB,M,EAA2C;AAAA,UAA3BlC,KAA2B,uEAAX,CAAW;AAAA,UACxEU,MADwE,GACnD,IADmD,CACxEA,MADwE;AAAA,UAChEC,QADgE,GACnD,IADmD,CAChEA,QADgE;AAGhF,aAAO,oBACL,mBAAMuB,MAAN,CADK,EAEL,UAACC,GAAD,EAAMC,KAAN,EAAarC,KAAb,EAAuB;AACrBoC,QAAAA,GAAG,gBAASpC,KAAT,EAAH,GAAuB,iBACrBa,QADqB,EAErB,WAAIZ,KAAJ,SAAe,mBAAMD,KAAN,EAAa;AAAA,2BAASW,MAAT,cAAmBV,KAAnB;AAAA,SAAb,EAA0CqC,IAA1C,CAA+C,GAA/C,CAAf,GAAqE1B,QAFhD,CAAvB;AAIA,eAAOwB,GAAP;AACD,OARI,EASL,EATK,CAAP;AAWD;AAED;;;;;;qCAKEvB,Q,EACA0B,M,EACAvC,K,EAKA;AACA,UAAImB,IAAI,GAAG,EAAX;AADA,UAEQR,MAFR,GAE6B,IAF7B,CAEQA,MAFR;AAAA,UAEgBC,QAFhB,GAE6B,IAF7B,CAEgBA,QAFhB;;AAIA,UAAIZ,KAAK,IAAI,CAAb,EAAgB;AACd,eAAO;AAAEa,UAAAA,QAAQ,EAAEA,QAAQ,IAAI,EAAxB;AAA4BM,UAAAA,IAAI,EAAJA,IAA5B;AAAkCqB,UAAAA,MAAM,EAAE;AAA1C,SAAP;AACD;;AAED,UAAMC,SAAS,GAAGzC,KAAK,GAAG,CAA1B;;AACA,UAAIuC,MAAM,IAAI,qBAAQA,MAAM,gBAASE,SAAT,EAAd,CAAd,EAAoD;AAClD,eAAO;AAAE5B,UAAAA,QAAQ,EAAE,EAAZ;AAAgBM,UAAAA,IAAI,EAAJA,IAAhB;AAAsBqB,UAAAA,MAAM,EAAE;AAA9B,SAAP;AACD;;AAED,UAAME,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACf,UAAD,EAAqBZ,QAArB,EAAuC4B,WAAvC,EAAuE;AAC9F,YAAMC,WAAW,GAAGL,MAAM,IAAIA,MAAM,gBAASZ,UAAT,EAApC;AACA,YAAMkB,OAAO,GAAG,kBAAKF,WAAL,EAAkB,UAACvB,OAAD;AAAA,iBAAa,iBAAIA,OAAJ,EAAaR,QAAb,MAA2BgC,WAAxC;AAAA,SAAlB,CAAhB;AACA,YAAME,YAAY,GAAG,qBAAQH,WAAR,EAAqBE,OAArB,CAArB;AACA1B,QAAAA,IAAI,eAAQ2B,YAAR,eAAyBnC,MAAzB,CAAJ;;AAEA,YAAI,CAACkC,OAAL,EAAc;AACZ,iBAAO;AAAEF,YAAAA,WAAW,EAAE,EAAf;AAAmBH,YAAAA,MAAM,EAAE;AAA3B,WAAP;AACD;;AAED,YAAIb,UAAU,IAAIZ,QAAlB,EAA4B;AAC1B,iBAAO;AACL4B,YAAAA,WAAW,EAAEE,OAAO,CAAClC,MAAD,CAAP,IAAmB,EAD3B;AAEL6B,YAAAA,MAAM,EAAE;AAAEpB,cAAAA,OAAO,EAAEyB,OAAX;AAAoB5C,cAAAA,KAAK,EAAE6C,YAA3B;AAAyC9C,cAAAA,KAAK,EAAE2B;AAAhD;AAFH,WAAP;AAID;;AAED,eAAOe,gBAAgB,CAACf,UAAU,GAAG,CAAd,EAAiBZ,QAAjB,EAA2B8B,OAAO,CAAClC,MAAD,CAAP,IAAmB,EAA9C,CAAvB;AACD,OAlBD;;AAbA,8BAiCgC+B,gBAAgB,CAAC,CAAD,EAAID,SAAJ,EAAe5B,QAAf,CAjChD;AAAA,UAiCQ8B,WAjCR,qBAiCQA,WAjCR;AAAA,UAiCqBH,MAjCrB,qBAiCqBA,MAjCrB;;AAkCA,aAAO;AAAE3B,QAAAA,QAAQ,EAAE8B,WAAZ;AAAyBxB,QAAAA,IAAI,EAAJA,IAAzB;AAA+BqB,QAAAA,MAAM,EAANA;AAA/B,OAAP;AACD;;;;;;eAGY9B,a","sourcesContent":["import { isEmpty, forEach, isUndefined, cloneDeep, get, find, reduce, indexOf, times } from 'lodash'\n\nexport interface Cascade {\n  [key: string]: any\n}\n\ninterface Strs {\n  [key: string]: string\n}\n\ninterface Values {\n  [key: string]: any\n}\n\ninterface FlattenResult {\n  strs: Strs\n  cascade: Cascade\n  path: string\n}\n\nexport const generateRandomString = (level: number = 0, index: number = 0): string => {\n  const str = Math.random()\n    .toString(36)\n    .substr(2, 7)\n\n  return str + '-' + level + '-' + index\n}\n\nconst generateCascade = (level: number, index: number): Cascade => ({\n  name: `${level}.${index}`,\n  value: generateRandomString(level, index),\n})\n\nclass CascadeHelper {\n  public subKey: string\n  public valueKey: string\n  public constructor(subKey: string = 'children', valueKey: string = 'value') {\n    this.subKey = subKey\n    this.valueKey = valueKey\n  }\n\n  public flatten(cascades: Cascade[], labels: string[] = [], endLevel?: number): FlattenResult[] {\n    const results: FlattenResult[] = []\n    const { subKey } = this\n\n    const traverse = (cascades: Cascade[], strs: Strs = {}, path?: string, level?: number): void => {\n      forEach(cascades, (cascade, index) => {\n        let cStrs: Strs = {}\n        forEach(labels, (label) => {\n          cStrs[label] = !isUndefined(strs[label]) ? strs[label] + '-' + cascade[label] : cascade[label]\n        })\n\n        let cLevel = !isUndefined(level) ? level : 0\n        const cPath = !isUndefined(path) ? `${path}.${subKey}[${index}]` : `[${index}]`\n\n        if (!isEmpty(cascade[subKey]) && (isUndefined(endLevel) || (!isUndefined(endLevel) && cLevel < endLevel))) {\n          cLevel++\n          return traverse(cascade[subKey], cStrs, cPath, cLevel)\n        }\n\n        results.push({ strs: cStrs, cascade: cloneDeep(cascade), path: cPath })\n      })\n    }\n\n    traverse(cascades)\n    return results\n  }\n\n  /*\n   * Fill cascade\n   */\n  public cascadesFill(\n    cascades: Cascade[] = [],\n    count: number = 2,\n    startLevel: number = 0,\n    endLevel: number = 1,\n    geterateFunc: (level: number, index: number) => Cascade = generateCascade\n  ): Cascade[] {\n    const { subKey } = this\n    let newCascades = { [subKey]: cloneDeep(cascades) }\n\n    if (startLevel > endLevel) {\n      return newCascades[subKey]\n    }\n\n    const setInit = (level: number, cascade: Cascade): void => {\n      if (isUndefined(cascade[subKey])) {\n        cascade[subKey] = []\n      }\n\n      if (isEmpty(cascade[subKey])) {\n        times(count, (xIndex) => {\n          if (isUndefined(cascade[subKey][xIndex])) {\n            cascade[subKey][xIndex] = geterateFunc(level, xIndex)\n          }\n        })\n      }\n\n      forEach(cascade[subKey], (choice) => {\n        if (level < endLevel) {\n          setInit(level + 1, choice)\n        }\n      })\n    }\n\n    setInit(startLevel, newCascades)\n    return newCascades[subKey]\n  }\n\n  /*\n   * For each cascade\n   */\n  public cascadesForEach(\n    cascades: Cascade[],\n    cb: (cascade: Cascade, currentlevel?: number, currentIndex?: number) => void,\n    startLevel: number = 0,\n    endLevel?: number\n  ): void {\n    const { subKey } = this\n\n    forEach(cascades, (cascade, index) => {\n      cb(cascade, startLevel, index)\n      if (!isEmpty(cascade[subKey])) {\n        if (endLevel && startLevel >= endLevel) {\n          return\n        }\n\n        this.cascadesForEach(cascade[subKey], cb, startLevel + 1, endLevel)\n      }\n    })\n  }\n\n  /*\n   * Get init values\n   * Get the first value of cascades by default\n   */\n  public initValues(cascades: Cascade[], levels: number, index: number = 0): Values {\n    const { subKey, valueKey } = this\n\n    return reduce<any, { [key: string]: string }>(\n      times(levels),\n      (acc, _curr, level) => {\n        acc[`level${level}`] = get(\n          cascades,\n          `[${index}]` + times(level, () => `${subKey}[${index}]`).join('.') + valueKey\n        )\n        return acc\n      },\n      {}\n    )\n  }\n\n  /*\n   * Get the specified level cascades by current values\n   */\n\n  public getLevelCascades(\n    cascades: Cascade[],\n    values: Values,\n    level: number\n  ): {\n    cascades: Cascade[]\n    path: string\n    parent: Cascade | null\n  } {\n    let path = ''\n    const { subKey, valueKey } = this\n\n    if (level <= 0) {\n      return { cascades: cascades || [], path, parent: null }\n    }\n\n    const prevLevel = level - 1\n    if (values && isEmpty(values[`level${prevLevel}`])) {\n      return { cascades: [], path, parent: null }\n    }\n\n    const querySubCascades = (startLevel: number, endLevel: number, subCascades: Cascade[]): any => {\n      const targetValue = values && values[`level${startLevel}`]\n      const current = find(subCascades, (cascade) => get(cascade, valueKey) === targetValue)\n      const currentIndex = indexOf(subCascades, current)\n      path += `[${currentIndex}].${subKey}`\n\n      if (!current) {\n        return { subCascades: [], parent: null }\n      }\n\n      if (startLevel >= endLevel) {\n        return {\n          subCascades: current[subKey] || [],\n          parent: { cascade: current, index: currentIndex, level: startLevel },\n        }\n      }\n\n      return querySubCascades(startLevel + 1, endLevel, current[subKey] || [])\n    }\n\n    const { subCascades, parent } = querySubCascades(0, prevLevel, cascades)\n    return { cascades: subCascades, path, parent }\n  }\n}\n\nexport default CascadeHelper\n"],"file":"index.js"}