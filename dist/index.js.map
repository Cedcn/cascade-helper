{"version":3,"sources":["../src/index.ts"],"names":["generateRandomString","level","index","str","Math","random","toString","substr","generateCascade","name","value","CascadeHelper","subKey","valueKey","cascades","labels","itemSeparator","endLevel","results","iteratorCascades","strs","path","cascade","cStrs","label","cLevel","cPath","push","count","geterateFunc","startLevel","newCascades","setInit","xIndex","item","cb","cascadesForEach","levelCount","acc","_curr","join","values","parent","prevLevel","iteratorSubCascades","subCascades","targetValue","current","currentIndex","levelSeparator","parseLabels","tArr","result","curr","newCurr","length","key","trimedStr","arr","split","flatten"],"mappings":";;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;AAoBO,IAAMA,oBAAoB,GAAG,SAAvBA,oBAAuB,GAAkD;AAAA,MAAjDC,KAAiD,uEAAjC,CAAiC;AAAA,MAA9BC,KAA8B,uEAAd,CAAc;AACpF,MAAMC,GAAG,GAAGC,IAAI,CAACC,MAAL,GACTC,QADS,CACA,EADA,EAETC,MAFS,CAEF,CAFE,EAEC,CAFD,CAAZ;AAIA,SAAOJ,GAAG,GAAG,GAAN,GAAYF,KAAZ,GAAoB,GAApB,GAA0BC,KAAjC;AACD,CANM;;;;AAQP,IAAMM,eAAe,GAAG,SAAlBA,eAAkB,CAACP,KAAD,EAAgBC,KAAhB;AAAA,SAA4C;AAClEO,IAAAA,IAAI,YAAKR,KAAL,cAAcC,KAAd,CAD8D;AAElEQ,IAAAA,KAAK,EAAEV,oBAAoB,CAACC,KAAD,EAAQC,KAAR;AAFuC,GAA5C;AAAA,CAAxB;;IAKMS,a;;;AAGJ,2BAA4E;AAAA,QAAzDC,MAAyD,uEAAxC,UAAwC;AAAA,QAA5BC,QAA4B,uEAAT,OAAS;;AAAA;;AAAA;;AAAA;;AAC1E,SAAKD,MAAL,GAAcA,MAAd;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACD;;;;4BAGCC,Q,EAIiB;AAAA,UAHjBC,MAGiB,uEAHE,EAGF;AAAA,UAFjBC,aAEiB,uEAFO,GAEP;AAAA,UADjBC,QACiB;AACjB,UAAMC,OAAwB,GAAG,EAAjC;AADiB,UAETN,MAFS,GAEE,IAFF,CAETA,MAFS;;AAIjB,UAAMO,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACL,QAAD,EAA+E;AAAA,YAAzDM,IAAyD,uEAA5C,EAA4C;AAAA,YAAxCC,IAAwC;AAAA,YAAzBpB,KAAyB;AACtG,6BAAQa,QAAR,EAAkB,UAACQ,OAAD,EAAUpB,KAAV,EAAoB;AACpC,cAAIqB,KAAW,GAAG,EAAlB;AACA,+BAAQR,MAAR,EAAgB,UAACS,KAAD,EAAW;AACzBD,YAAAA,KAAK,CAACC,KAAD,CAAL,GAAe,CAAC,yBAAYJ,IAAI,CAACI,KAAD,CAAhB,CAAD,GAA4BJ,IAAI,CAACI,KAAD,CAAJ,GAAcR,aAAd,GAA8BM,OAAO,CAACE,KAAD,CAAjE,GAA2EF,OAAO,CAACE,KAAD,CAAjG;AACD,WAFD;AAIA,cAAIC,MAAM,GAAG,CAAC,yBAAYxB,KAAZ,CAAD,GAAsBA,KAAtB,GAA8B,CAA3C;AACA,cAAMyB,KAAK,GAAG,CAAC,yBAAYL,IAAZ,CAAD,aAAwBA,IAAxB,cAAgCT,MAAhC,cAA0CV,KAA1C,oBAAyDA,KAAzD,MAAd;;AAEA,cAAI,CAAC,qBAAQoB,OAAO,CAACV,MAAD,CAAf,CAAD,KAA8B,yBAAYK,QAAZ,KAA0B,CAAC,yBAAYA,QAAZ,CAAD,IAA0BQ,MAAM,GAAGR,QAA3F,CAAJ,EAA2G;AACzGQ,YAAAA,MAAM;AACN,mBAAON,gBAAgB,CAACG,OAAO,CAACV,MAAD,CAAR,EAAkBW,KAAlB,EAAyBG,KAAzB,EAAgCD,MAAhC,CAAvB;AACD;;AAEDP,UAAAA,OAAO,CAACS,IAAR,CAAa;AAAEP,YAAAA,IAAI,EAAEG,KAAR;AAAeD,YAAAA,OAAO,EAAE,uBAAUA,OAAV,CAAxB;AAA4CD,YAAAA,IAAI,EAAEK;AAAlD,WAAb;AACD,SAfD;AAgBD,OAjBD;;AAmBAP,MAAAA,gBAAgB,CAACL,QAAD,CAAhB;AACA,aAAOI,OAAP;AACD;AAED;;;;;;mCASa;AAAA,UALXJ,QAKW,uEALW,EAKX;AAAA,UAJXc,KAIW,uEAJK,CAIL;AAAA,UAHXC,YAGW,uEAH+CrB,eAG/C;AAAA,UAFXsB,UAEW,uEAFU,CAEV;AAAA,UADXb,QACW,uEADQ,CACR;AAAA,UACHL,MADG,GACQ,IADR,CACHA,MADG;;AAEX,UAAImB,WAAW,uBAAMnB,MAAN,EAAe,uBAAUE,QAAV,CAAf,CAAf;;AAEA,UAAIgB,UAAU,GAAGb,QAAjB,EAA2B;AACzB,eAAOc,WAAW,CAACnB,MAAD,CAAlB;AACD;;AAED,UAAMoB,OAAO,GAAG,SAAVA,OAAU,CAAC/B,KAAD,EAAgBqB,OAAhB,EAA2C;AACzD,YAAI,yBAAYA,OAAO,CAACV,MAAD,CAAnB,CAAJ,EAAkC;AAChCU,UAAAA,OAAO,CAACV,MAAD,CAAP,GAAkB,EAAlB;AACD;;AAED,YAAI,qBAAQU,OAAO,CAACV,MAAD,CAAf,CAAJ,EAA8B;AAC5B,6BAAMgB,KAAN,EAAa,UAACK,MAAD,EAAY;AACvB,gBAAI,yBAAYX,OAAO,CAACV,MAAD,CAAP,CAAgBqB,MAAhB,CAAZ,CAAJ,EAA0C;AACxCX,cAAAA,OAAO,CAACV,MAAD,CAAP,CAAgBqB,MAAhB,IAA0BJ,YAAY,CAAC5B,KAAD,EAAQgC,MAAR,CAAtC;AACD;AACF,WAJD;AAKD;;AAED,6BAAQX,OAAO,CAACV,MAAD,CAAf,EAAyB,UAACsB,IAAD,EAAU;AACjC,cAAIjC,KAAK,GAAGgB,QAAZ,EAAsB;AACpBe,YAAAA,OAAO,CAAC/B,KAAK,GAAG,CAAT,EAAYiC,IAAZ,CAAP;AACD;AACF,SAJD;AAKD,OAlBD;;AAoBAF,MAAAA,OAAO,CAACF,UAAD,EAAaC,WAAb,CAAP;AACA,aAAOA,WAAW,CAACnB,MAAD,CAAlB;AACD;AAED;;;;;;oCAIEE,Q,EACAqB,E,EAGM;AAAA;;AAAA,UAFNL,UAEM,uEAFe,CAEf;AAAA,UADNb,QACM;AAAA,UACEL,MADF,GACa,IADb,CACEA,MADF;AAGN,2BAAQE,QAAR,EAAkB,UAACQ,OAAD,EAAUpB,KAAV,EAAoB;AACpCiC,QAAAA,EAAE,CAACb,OAAD,EAAUQ,UAAV,EAAsB5B,KAAtB,CAAF;;AACA,YAAI,CAAC,qBAAQoB,OAAO,CAACV,MAAD,CAAf,CAAL,EAA+B;AAC7B,cAAIK,QAAQ,IAAIa,UAAU,IAAIb,QAA9B,EAAwC;AACtC;AACD;;AAED,UAAA,KAAI,CAACmB,eAAL,CAAqBd,OAAO,CAACV,MAAD,CAA5B,EAAsCuB,EAAtC,EAA0CL,UAAU,GAAG,CAAvD,EAA0Db,QAA1D;AACD;AACF,OATD;AAUD;AAED;;;;;;;+BAIkBH,Q,EAAqBuB,U,EAA+C;AAAA,UAA3BnC,KAA2B,uEAAX,CAAW;AAAA,UAC5EU,MAD4E,GACvD,IADuD,CAC5EA,MAD4E;AAAA,UACpEC,QADoE,GACvD,IADuD,CACpEA,QADoE;AAGpF,aAAO,oBACL,mBAAMwB,UAAN,CADK,EAEL,UAACC,GAAD,EAAMC,KAAN,EAAatC,KAAb,EAAuB;AACrBqC,QAAAA,GAAG,gBAASrC,KAAT,EAAH,GAAuB,iBACrBa,QADqB,EAErB,WAAIZ,KAAJ,SAAe,mBAAMD,KAAN,EAAa;AAAA,2BAASW,MAAT,cAAmBV,KAAnB;AAAA,SAAb,EAA0CsC,IAA1C,CAA+C,GAA/C,CAAf,GAAqE3B,QAFhD,CAAvB;AAIA,eAAOyB,GAAP;AACD,OARI,EASL,EATK,CAAP;AAWD;AAED;;;;;;qCAIExB,Q,EACA2B,M,EACAxC,K,EAKA;AACA,UAAIoB,IAAI,GAAG,EAAX;AADA,UAEQT,MAFR,GAE6B,IAF7B,CAEQA,MAFR;AAAA,UAEgBC,QAFhB,GAE6B,IAF7B,CAEgBA,QAFhB;;AAIA,UAAIZ,KAAK,IAAI,CAAb,EAAgB;AACd,eAAO;AAAEa,UAAAA,QAAQ,EAAEA,QAAQ,IAAI,EAAxB;AAA4BO,UAAAA,IAAI,EAAJA,IAA5B;AAAkCqB,UAAAA,MAAM,EAAE;AAA1C,SAAP;AACD;;AAED,UAAMC,SAAS,GAAG1C,KAAK,GAAG,CAA1B;;AACA,UAAIwC,MAAM,IAAI,qBAAQA,MAAM,gBAASE,SAAT,EAAd,CAAd,EAAoD;AAClD,eAAO;AAAE7B,UAAAA,QAAQ,EAAE,EAAZ;AAAgBO,UAAAA,IAAI,EAAJA,IAAhB;AAAsBqB,UAAAA,MAAM,EAAE;AAA9B,SAAP;AACD;;AAED,UAAME,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACd,UAAD,EAAqBb,QAArB,EAAuC4B,WAAvC,EAAuE;AACjG,YAAMC,WAAW,GAAGL,MAAM,IAAIA,MAAM,gBAASX,UAAT,EAApC;AACA,YAAMiB,OAAO,GAAG,kBAAKF,WAAL,EAAkB,UAACvB,OAAD;AAAA,iBAAa,iBAAIA,OAAJ,EAAaT,QAAb,MAA2BiC,WAAxC;AAAA,SAAlB,CAAhB;AACA,YAAME,YAAY,GAAG,qBAAQH,WAAR,EAAqBE,OAArB,CAArB;AACA1B,QAAAA,IAAI,eAAQ2B,YAAR,eAAyBpC,MAAzB,CAAJ;;AAEA,YAAI,CAACmC,OAAL,EAAc;AACZ,iBAAO;AAAEF,YAAAA,WAAW,EAAE,EAAf;AAAmBH,YAAAA,MAAM,EAAE;AAA3B,WAAP;AACD;;AAED,YAAIZ,UAAU,IAAIb,QAAlB,EAA4B;AAC1B,iBAAO;AACL4B,YAAAA,WAAW,EAAEE,OAAO,CAACnC,MAAD,CAAP,IAAmB,EAD3B;AAEL8B,YAAAA,MAAM,EAAE;AAAEpB,cAAAA,OAAO,EAAEyB,OAAX;AAAoB7C,cAAAA,KAAK,EAAE8C,YAA3B;AAAyC/C,cAAAA,KAAK,EAAE6B;AAAhD;AAFH,WAAP;AAID;;AAED,eAAOc,mBAAmB,CAACd,UAAU,GAAG,CAAd,EAAiBb,QAAjB,EAA2B8B,OAAO,CAACnC,MAAD,CAAP,IAAmB,EAA9C,CAA1B;AACD,OAlBD;;AAbA,iCAiCgCgC,mBAAmB,CAAC,CAAD,EAAID,SAAJ,EAAe7B,QAAf,CAjCnD;AAAA,UAiCQ+B,WAjCR,wBAiCQA,WAjCR;AAAA,UAiCqBH,MAjCrB,wBAiCqBA,MAjCrB;;AAkCA,aAAO;AAAE5B,QAAAA,QAAQ,EAAE+B,WAAZ;AAAyBxB,QAAAA,IAAI,EAAJA,IAAzB;AAA+BqB,QAAAA,MAAM,EAANA;AAA/B,OAAP;AACD;AAED;;;;;;0BAIEvC,G,EACAgC,E,EAGW;AAAA,UAFXnB,aAEW,uEAFa,GAEb;AAAA,UADXiC,cACW,uEADc,IACd;AAAA,UACHrC,MADG,GACkB,IADlB,CACHA,MADG;AAAA,UACKC,QADL,GACkB,IADlB,CACKA,QADL;;AAEX,UAAMqC,WAAW,GAAG,SAAdA,WAAc,CAACC,IAAD,EAAoD;AAAA,YAAjClD,KAAiC,uEAAjB,CAAiB;AACtE,YAAMmD,MAAM,GAAG,oBACbD,IADa,EAEb,UAACb,GAAD,EAAMe,IAAN,EAAe;AACb,cAAI,CAACf,GAAG,CAACe,IAAI,CAAC,CAAD,CAAL,CAAR,EAAmB;AACjBf,YAAAA,GAAG,CAACe,IAAI,CAAC,CAAD,CAAL,CAAH,GAAe,EAAf;AACD;;AACD,cAAMC,OAAO,GAAG,oBAAOD,IAAP,EAAa,UAACnB,IAAD;AAAA,mBAAUA,IAAI,KAAKmB,IAAI,CAAC,CAAD,CAAvB;AAAA,WAAb,CAAhB;;AACA,cAAIC,OAAO,CAACC,MAAR,GAAiB,CAArB,EAAwB;AACtBjB,YAAAA,GAAG,CAACe,IAAI,CAAC,CAAD,CAAL,CAAH,gCAAmBf,GAAG,CAACe,IAAI,CAAC,CAAD,CAAL,CAAtB,IAAiCC,OAAjC;AACD;;AAED,iBAAOhB,GAAP;AACD,SAZY,EAab,EAba,CAAf;AAeA,YAAMb,MAAM,GAAGxB,KAAf;AACA,YAAIC,KAAK,GAAG,CAAZ;AACAD,QAAAA,KAAK;AACL,eAAO,iBAAImD,MAAJ,EAAY,UAAClB,IAAD,EAAOsB,GAAP,EAAe;AAChC,cAAIlC,OAAJ;;AAEA,cAAI,qBAAQY,IAAR,CAAJ,EAAmB;AACjBZ,YAAAA,OAAO,qBAAQa,EAAE,CAACqB,GAAD,EAAM3C,QAAN,EAAgBY,MAAhB,EAAwBvB,KAAxB,CAAV,CAAP;AACD,WAFD,MAEO;AACLoB,YAAAA,OAAO,qCACJV,MADI,EACKsC,WAAW,CAAChB,IAAD,EAAOjC,KAAP,CADhB,GAEFkC,EAAE,CAACqB,GAAD,EAAM3C,QAAN,EAAgBY,MAAhB,EAAwBvB,KAAxB,CAFA,CAAP;AAID;;AAEDA,UAAAA,KAAK;AACL,iBAAOoB,OAAP;AACD,SAdM,CAAP;AAeD,OAlCD;;AAoCA,UAAMmC,SAAS,GAAG,kBAAKtD,GAAL,CAAlB;;AACA,UAAI,qBAAQsD,SAAR,CAAJ,EAAwB;AACtB,eAAO,EAAP;AACD;;AACD,UAAMC,GAAG,GAAGD,SAAS,CAACE,KAAV,CAAgBV,cAAhB,CAAZ;AACA,UAAME,IAAI,GAAG,iBAAIO,GAAJ,EAAS,UAACxB,IAAD;AAAA,eAAUA,IAAI,CAACyB,KAAL,CAAW3C,aAAX,CAAV;AAAA,OAAT,CAAb;AAEA,aAAOkC,WAAW,CAACC,IAAD,CAAlB;AACD;AAED;;;;;;8BAKErC,Q,EACAU,K,EAIQ;AAAA,UAHRR,aAGQ,uEAHgB,GAGhB;AAAA,UAFRiC,cAEQ,uEAFiB,IAEjB;AAAA,UADRhC,QACQ;AACR,UAAMC,OAAO,GAAG,KAAK0C,OAAL,CAAa9C,QAAb,EAAuB,CAACU,KAAD,CAAvB,EAAgCR,aAAhC,EAA+CC,QAA/C,CAAhB;AACA,aAAO,iBAAIC,OAAJ,EAAa,UAACgB,IAAD;AAAA,eAAUA,IAAI,CAACd,IAAL,CAAUI,KAAV,CAAV;AAAA,OAAb,EAAyCgB,IAAzC,CAA8CS,cAA9C,CAAP;AACD;;;;;;eAGYtC,a","sourcesContent":["import { isEmpty, forEach, isUndefined, cloneDeep, get, trim, find, filter, map, reduce, indexOf, times } from 'lodash'\n\nexport interface Cascade {\n  [key: string]: any\n}\n\ninterface Strs {\n  [key: string]: string\n}\n\ninterface Values {\n  [key: string]: any\n}\n\ninterface FlattenResult {\n  strs: Strs\n  cascade: Cascade\n  path: string\n}\n\nexport const generateRandomString = (level: number = 0, index: number = 0): string => {\n  const str = Math.random()\n    .toString(36)\n    .substr(2, 7)\n\n  return str + '-' + level + '-' + index\n}\n\nconst generateCascade = (level: number, index: number): Cascade => ({\n  name: `${level}.${index}`,\n  value: generateRandomString(level, index),\n})\n\nclass CascadeHelper {\n  public subKey: string\n  public valueKey: string\n  public constructor(subKey: string = 'children', valueKey: string = 'value') {\n    this.subKey = subKey\n    this.valueKey = valueKey\n  }\n\n  public flatten(\n    cascades: Cascade[],\n    labels: string[] = [],\n    itemSeparator: string = '-',\n    endLevel?: number\n  ): FlattenResult[] {\n    const results: FlattenResult[] = []\n    const { subKey } = this\n\n    const iteratorCascades = (cascades: Cascade[], strs: Strs = {}, path?: string, level?: number): void => {\n      forEach(cascades, (cascade, index) => {\n        let cStrs: Strs = {}\n        forEach(labels, (label) => {\n          cStrs[label] = !isUndefined(strs[label]) ? strs[label] + itemSeparator + cascade[label] : cascade[label]\n        })\n\n        let cLevel = !isUndefined(level) ? level : 0\n        const cPath = !isUndefined(path) ? `${path}.${subKey}[${index}]` : `[${index}]`\n\n        if (!isEmpty(cascade[subKey]) && (isUndefined(endLevel) || (!isUndefined(endLevel) && cLevel < endLevel))) {\n          cLevel++\n          return iteratorCascades(cascade[subKey], cStrs, cPath, cLevel)\n        }\n\n        results.push({ strs: cStrs, cascade: cloneDeep(cascade), path: cPath })\n      })\n    }\n\n    iteratorCascades(cascades)\n    return results\n  }\n\n  /*\n   * Fill cascade\n   */\n  public cascadesFill(\n    cascades: Cascade[] = [],\n    count: number = 2,\n    geterateFunc: (level: number, index: number) => Cascade = generateCascade,\n    startLevel: number = 0,\n    endLevel: number = 1\n  ): Cascade[] {\n    const { subKey } = this\n    let newCascades = { [subKey]: cloneDeep(cascades) }\n\n    if (startLevel > endLevel) {\n      return newCascades[subKey]\n    }\n\n    const setInit = (level: number, cascade: Cascade): void => {\n      if (isUndefined(cascade[subKey])) {\n        cascade[subKey] = []\n      }\n\n      if (isEmpty(cascade[subKey])) {\n        times(count, (xIndex) => {\n          if (isUndefined(cascade[subKey][xIndex])) {\n            cascade[subKey][xIndex] = geterateFunc(level, xIndex)\n          }\n        })\n      }\n\n      forEach(cascade[subKey], (item) => {\n        if (level < endLevel) {\n          setInit(level + 1, item)\n        }\n      })\n    }\n\n    setInit(startLevel, newCascades)\n    return newCascades[subKey]\n  }\n\n  /*\n   * For each cascade\n   */\n  public cascadesForEach(\n    cascades: Cascade[],\n    cb: (cascade: Cascade, currentlevel?: number, currentIndex?: number) => void,\n    startLevel: number = 0,\n    endLevel?: number\n  ): void {\n    const { subKey } = this\n\n    forEach(cascades, (cascade, index) => {\n      cb(cascade, startLevel, index)\n      if (!isEmpty(cascade[subKey])) {\n        if (endLevel && startLevel >= endLevel) {\n          return\n        }\n\n        this.cascadesForEach(cascade[subKey], cb, startLevel + 1, endLevel)\n      }\n    })\n  }\n\n  /*\n   * Get init values\n   * Get the first value of cascades by default\n   */\n  public initValues(cascades: Cascade[], levelCount: number, index: number = 0): Values {\n    const { subKey, valueKey } = this\n\n    return reduce<any, { [key: string]: string }>(\n      times(levelCount),\n      (acc, _curr, level) => {\n        acc[`level${level}`] = get(\n          cascades,\n          `[${index}]` + times(level, () => `${subKey}[${index}]`).join('.') + valueKey\n        )\n        return acc\n      },\n      {}\n    )\n  }\n\n  /*\n   * Get the specified level cascades by current values\n   */\n  public getLevelCascades(\n    cascades: Cascade[],\n    values: Values,\n    level: number\n  ): {\n    cascades: Cascade[]\n    path: string\n    parent: Cascade | null\n  } {\n    let path = ''\n    const { subKey, valueKey } = this\n\n    if (level <= 0) {\n      return { cascades: cascades || [], path, parent: null }\n    }\n\n    const prevLevel = level - 1\n    if (values && isEmpty(values[`level${prevLevel}`])) {\n      return { cascades: [], path, parent: null }\n    }\n\n    const iteratorSubCascades = (startLevel: number, endLevel: number, subCascades: Cascade[]): any => {\n      const targetValue = values && values[`level${startLevel}`]\n      const current = find(subCascades, (cascade) => get(cascade, valueKey) === targetValue)\n      const currentIndex = indexOf(subCascades, current)\n      path += `[${currentIndex}].${subKey}`\n\n      if (!current) {\n        return { subCascades: [], parent: null }\n      }\n\n      if (startLevel >= endLevel) {\n        return {\n          subCascades: current[subKey] || [],\n          parent: { cascade: current, index: currentIndex, level: startLevel },\n        }\n      }\n\n      return iteratorSubCascades(startLevel + 1, endLevel, current[subKey] || [])\n    }\n\n    const { subCascades, parent } = iteratorSubCascades(0, prevLevel, cascades)\n    return { cascades: subCascades, path, parent }\n  }\n\n  /*\n   * To structure cascades by text\n   */\n  public parse(\n    str: string,\n    cb: (key: string, valueKey: string, level: number, index: number) => Cascade,\n    itemSeparator: string = '-',\n    levelSeparator: string = '\\n'\n  ): Cascade[] {\n    const { subKey, valueKey } = this\n    const parseLabels = (tArr: string[][], level: number = 0): Cascade[] => {\n      const result = reduce<any, { [key: string]: string[][] }>(\n        tArr,\n        (acc, curr) => {\n          if (!acc[curr[0]]) {\n            acc[curr[0]] = []\n          }\n          const newCurr = filter(curr, (item) => item !== curr[0])\n          if (newCurr.length > 0) {\n            acc[curr[0]] = [...acc[curr[0]], newCurr]\n          }\n\n          return acc\n        },\n        {}\n      )\n      const cLevel = level\n      let index = 0\n      level++\n      return map(result, (item, key) => {\n        let cascade\n\n        if (isEmpty(item)) {\n          cascade = { ...cb(key, valueKey, cLevel, index) }\n        } else {\n          cascade = {\n            [subKey]: parseLabels(item, level),\n            ...cb(key, valueKey, cLevel, index),\n          }\n        }\n\n        index++\n        return cascade\n      })\n    }\n\n    const trimedStr = trim(str)\n    if (isEmpty(trimedStr)) {\n      return []\n    }\n    const arr = trimedStr.split(levelSeparator)\n    const tArr = map(arr, (item) => item.split(itemSeparator))\n\n    return parseLabels(tArr)\n  }\n\n  /*\n   * Serialize string to cascades\n   */\n\n  public stringify(\n    cascades: Cascade[],\n    label: string,\n    itemSeparator: string = '-',\n    levelSeparator: string = '\\n',\n    endLevel?: number\n  ): string {\n    const results = this.flatten(cascades, [label], itemSeparator, endLevel)\n    return map(results, (item) => item.strs[label]).join(levelSeparator)\n  }\n}\n\nexport default CascadeHelper\n"],"file":"index.js"}