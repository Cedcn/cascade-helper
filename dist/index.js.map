{"version":3,"sources":["../src/index.ts"],"names":["generateRandomString","level","index","str","Math","random","toString","substr","generateCascade","name","value","CascadeHelper","subKey","valueKey","cascades","levels","acc","_curr","join","labels","endLevel","results","traverse","strs","path","cascade","cStrs","label","cLevel","cPath","push","count","startLevel","geterateFunc","newCascades","setInit","xIndex","choice","cb","cascadeForEach"],"mappings":"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","sourcesContent":["import { isEmpty, forEach, isUndefined, cloneDeep, get, reduce, times } from 'lodash'\n\nexport interface Cascade {\n  [key: string]: any\n}\n\ninterface Strs {\n  [key: string]: string\n}\n\ninterface FlattenResult {\n  strs: Strs\n  cascade: Cascade\n  path: string\n}\n\nexport const generateRandomString = (level: number = 0, index: number = 0): string => {\n  const str = Math.random()\n    .toString(36)\n    .substr(2, 7)\n\n  return str + '-' + level + '-' + index\n}\n\nconst generateCascade = (level: number, index: number): Cascade => ({\n  name: `${level}.${index}`,\n  value: generateRandomString(level, index),\n})\n\nclass CascadeHelper {\n  public subKey: string\n  public valueKey: string\n  public constructor(subKey: string = 'children', valueKey: string = 'value') {\n    this.subKey = subKey\n    this.valueKey = valueKey\n  }\n\n  public flatten(cascades: Cascade[], labels: string[] = [], endLevel?: number): FlattenResult[] {\n    const results: FlattenResult[] = []\n    const { subKey } = this\n\n    const traverse = (cascades: Cascade[], strs: Strs = {}, path?: string, level?: number): void => {\n      forEach(cascades, (cascade, index) => {\n        let cStrs: Strs = {}\n        forEach(labels, (label) => {\n          cStrs[label] = !isUndefined(strs[label]) ? strs[label] + '-' + cascade[label] : cascade[label]\n        })\n\n        let cLevel = !isUndefined(level) ? level : 0\n        const cPath = !isUndefined(path) ? `${path}.${subKey}[${index}]` : `[${index}]`\n\n        if (!isEmpty(cascade[subKey]) && (isUndefined(endLevel) || (!isUndefined(endLevel) && cLevel < endLevel))) {\n          cLevel++\n          return traverse(cascade[subKey], cStrs, cPath, cLevel)\n        }\n\n        results.push({ strs: cStrs, cascade: cloneDeep(cascade), path: cPath })\n      })\n    }\n\n    traverse(cascades)\n    return results\n  }\n\n  /*\n   * Fill cascade\n   */\n  public cascadeFill(\n    cascades: Cascade[] = [],\n    count: number = 2,\n    startLevel: number = 0,\n    endLevel: number = 1,\n    geterateFunc: (level: number, index: number) => Cascade = generateCascade\n  ): Cascade[] {\n    const { subKey } = this\n    let newCascades = { [subKey]: cloneDeep(cascades) }\n\n    if (startLevel > endLevel) {\n      return newCascades[subKey]\n    }\n\n    const setInit = (level: number, cascade: Cascade): void => {\n      if (isUndefined(cascade[subKey])) {\n        cascade[subKey] = []\n      }\n\n      if (isEmpty(cascade[subKey])) {\n        times(count, (xIndex) => {\n          if (isUndefined(cascade[subKey][xIndex])) {\n            cascade[subKey][xIndex] = geterateFunc(level, xIndex)\n          }\n        })\n      }\n\n      forEach(cascade[subKey], (choice) => {\n        if (level < endLevel) {\n          setInit(level + 1, choice)\n        }\n      })\n    }\n\n    setInit(startLevel, newCascades)\n    return newCascades[subKey]\n  }\n\n  /*\n   * For each cascade\n   */\n  public cascadeForEach(\n    cascades: Cascade[],\n    cb: (cascade: Cascade, currentlevel?: number, currentIndex?: number) => void,\n    startLevel: number = 0,\n    endLevel?: number\n  ): void {\n    const { subKey } = this\n\n    forEach(cascades, (cascade, index) => {\n      cb(cascade, startLevel, index)\n      if (!isEmpty(cascade[subKey])) {\n        if (endLevel && startLevel >= endLevel) {\n          return\n        }\n\n        this.cascadeForEach(cascade[subKey], cb, startLevel + 1, endLevel)\n      }\n    })\n  }\n\n  /*\n   * Get init values\n   * Get the first value of cascades by default\n   */\n  public initValues = (cascades: Cascade[], levels: number, index: number = 0) => {\n    const { subKey, valueKey } = this\n\n    return reduce<any, { [key: string]: string }>(\n      times(levels),\n      (acc, _curr, level) => {\n        acc[`level${level}`] = get(\n          cascades,\n          `[${index}]` + times(level, () => `${subKey}[${index}]`).join('.') + valueKey\n        )\n        return acc\n      },\n      {}\n    )\n  }\n}\n\nexport default CascadeHelper\n"],"file":"index.js"}